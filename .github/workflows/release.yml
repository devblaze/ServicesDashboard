name: Build and Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true

jobs:
  docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version_number }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          VERSION_NUMBER="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          echo "Version Number: $VERSION_NUMBER"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable Corepack
        run: corepack enable

      - name: Install frontend dependencies
        working-directory: ./services-dashboard-frontend
        run: yarn install --frozen-lockfile

      - name: Build frontend
        working-directory: ./services-dashboard-frontend
        run: yarn build

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./ServicesDashboard
          file: ./ServicesDashboard/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:${{ steps.version.outputs.version_number }}
            ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:buildcache,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./services-dashboard-frontend
          file: ./services-dashboard-frontend/Dockerfile.prod
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:${{ steps.version.outputs.version_number }}
            ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:latest
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:buildcache,mode=max

      - name: Image digest
        run: |
          echo "✅ Docker images pushed successfully!"
          echo "Backend: ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:${{ steps.version.outputs.version_number }}"
          echo "Frontend: ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:${{ steps.version.outputs.version_number }}"

  build:
    name: Build for ${{ matrix.name }}
    needs: docker
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          # Raspberry Pi 3/4 (ARM32v7) - Pi Zero NOT supported (ARMv6 incompatible with .NET 9)
          - name: Pi 3-4 32-bit
            artifact_name: pi-3-4-32bit
            runtime: linux-arm
            asset_name: servicesdashboard-pi-linux-arm.tar.gz

          # Raspberry Pi 4/5 64-bit (ARM64)
          - name: Pi 4-5 64-bit
            artifact_name: pi-4-5-64bit
            runtime: linux-arm64
            asset_name: servicesdashboard-pi-linux-arm64.tar.gz

          # Standard Linux x64
          - name: Linux x64
            artifact_name: linux-x64
            runtime: linux-x64
            asset_name: servicesdashboard-linux-x64.tar.gz

          # macOS x64
          - name: macOS x64
            artifact_name: macos-x64
            runtime: osx-x64
            asset_name: servicesdashboard-macos-x64.tar.gz

          # macOS ARM64 (M1/M2/M3)
          - name: macOS ARM64
            artifact_name: macos-arm64
            runtime: osx-arm64
            asset_name: servicesdashboard-macos-arm64.tar.gz

          # Windows x64
          - name: Windows x64
            artifact_name: windows-x64
            runtime: win-x64
            asset_name: servicesdashboard-windows-x64.zip

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable Corepack
        run: corepack enable

      - name: Install frontend dependencies
        working-directory: ./services-dashboard-frontend
        run: yarn install --frozen-lockfile

      - name: Build frontend
        working-directory: ./services-dashboard-frontend
        run: yarn build

      - name: Publish backend
        working-directory: ./ServicesDashboard
        run: |
          dotnet publish \
            --configuration Release \
            --runtime ${{ matrix.runtime }} \
            --self-contained true \
            -p:PublishSingleFile=true \
            -p:PublishTrimmed=true \
            -p:EnableCompressionInSingleFile=true \
            --output ./publish

      - name: Copy frontend build to backend
        run: |
          mkdir -p ServicesDashboard/publish/wwwroot
          cp -r services-dashboard-frontend/dist/* ServicesDashboard/publish/wwwroot/

      - name: Copy configuration files
        run: |
          cp ServicesDashboard/appsettings.json ServicesDashboard/publish/
          cp ServicesDashboard/appsettings.Production.json ServicesDashboard/publish/
          cp ServicesDashboard/appsettings.PiZero.json ServicesDashboard/publish/

      - name: Copy update script (Unix)
        if: ${{ !contains(matrix.runtime, 'win') }}
        run: |
          cp ServicesDashboard/update.sh ServicesDashboard/publish/
          chmod +x ServicesDashboard/publish/update.sh

      - name: Create installation script (Unix)
        if: ${{ !contains(matrix.runtime, 'win') }}
        working-directory: ./ServicesDashboard/publish
        run: |
          cat > install.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "🚀 Services Dashboard Installer"
          echo "================================"

          # Detect architecture
          ARCH=$(uname -m)
          IS_PI_ZERO=false

          if [ "$ARCH" = "armv6l" ] || [ "$ARCH" = "armv7l" ]; then
            IS_PI_ZERO=true
            echo "📟 Detected Raspberry Pi (ARM)"
          fi

          # Set installation directory
          INSTALL_DIR="/opt/servicesdashboard"
          DATA_DIR="/var/lib/servicesdashboard"
          SERVICE_FILE="/etc/systemd/system/servicesdashboard.service"

          echo "📂 Installing to: $INSTALL_DIR"

          # Check if running as root
          if [ "$EUID" -ne 0 ]; then
            echo "❌ Please run as root (use sudo)"
            exit 1
          fi

          # Create directories
          mkdir -p "$INSTALL_DIR"
          mkdir -p "$DATA_DIR"

          # Copy files
          echo "📦 Copying files..."
          cp -r ./* "$INSTALL_DIR/"
          chmod +x "$INSTALL_DIR/ServicesDashboard"

          # Choose configuration based on hardware
          if [ "$IS_PI_ZERO" = true ]; then
            echo "⚙️  Using Pi Zero configuration (SQLite)"
            export ASPNETCORE_ENVIRONMENT=PiZero
          else
            echo "⚙️  Using Production configuration"
            export ASPNETCORE_ENVIRONMENT=Production
          fi

          # Create systemd service
          echo "🔧 Creating systemd service..."
          cat > "$SERVICE_FILE" << SERVICEEOF
          [Unit]
          Description=Services Dashboard
          After=network.target

          [Service]
          Type=simple
          User=root
          WorkingDirectory=$INSTALL_DIR
          ExecStart=$INSTALL_DIR/ServicesDashboard
          Environment=ASPNETCORE_ENVIRONMENT=$ASPNETCORE_ENVIRONMENT
          Environment=ASPNETCORE_URLS=http://0.0.0.0:5050
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
          SERVICEEOF

          # Reload systemd and enable service
          systemctl daemon-reload
          systemctl enable servicesdashboard

          echo ""
          echo "✅ Installation complete!"
          echo ""
          echo "📝 To start the service:"
          echo "   sudo systemctl start servicesdashboard"
          echo ""
          echo "📊 To check status:"
          echo "   sudo systemctl status servicesdashboard"
          echo ""
          echo "📜 To view logs:"
          echo "   sudo journalctl -u servicesdashboard -f"
          echo ""
          echo "🌐 Access the dashboard at:"
          echo "   http://$(hostname -I | awk '{print $1}'):5050"
          echo ""
          EOF
          chmod +x install.sh

      - name: Create installation script (Windows)
        if: contains(matrix.runtime, 'win')
        working-directory: ./ServicesDashboard/publish
        run: |
          cat > install.ps1 << 'EOF'
          # Services Dashboard Windows Installer
          Write-Host "🚀 Services Dashboard Installer" -ForegroundColor Cyan
          Write-Host "================================" -ForegroundColor Cyan

          # Check for admin rights
          if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator"))
          {
              Write-Host "❌ Please run as Administrator" -ForegroundColor Red
              exit 1
          }

          $InstallDir = "C:\Program Files\ServicesDashboard"
          $DataDir = "C:\ProgramData\ServicesDashboard"

          Write-Host "📂 Installing to: $InstallDir" -ForegroundColor Green

          # Create directories
          New-Item -ItemType Directory -Force -Path $InstallDir | Out-Null
          New-Item -ItemType Directory -Force -Path $DataDir | Out-Null

          # Copy files
          Write-Host "📦 Copying files..." -ForegroundColor Green
          Copy-Item -Path ".\*" -Destination $InstallDir -Recurse -Force

          # Set environment variables
          [Environment]::SetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "Production", "Machine")
          [Environment]::SetEnvironmentVariable("ASPNETCORE_URLS", "http://0.0.0.0:5050", "Machine")

          Write-Host ""
          Write-Host "✅ Installation complete!" -ForegroundColor Green
          Write-Host ""
          Write-Host "📝 To start the service, run:" -ForegroundColor Yellow
          Write-Host "   cd '$InstallDir'" -ForegroundColor White
          Write-Host "   .\ServicesDashboard.exe" -ForegroundColor White
          Write-Host ""
          Write-Host "🌐 Access the dashboard at:" -ForegroundColor Yellow
          Write-Host "   http://localhost:5050" -ForegroundColor White
          Write-Host ""
          EOF

      - name: Create archive (Unix)
        if: ${{ !contains(matrix.runtime, 'win') }}
        working-directory: ./ServicesDashboard
        run: tar -czf ${{ matrix.asset_name }} -C publish .

      - name: Create archive (Windows)
        if: contains(matrix.runtime, 'win')
        working-directory: ./ServicesDashboard
        run: |
          cd publish
          zip -r ../${{ matrix.asset_name }} .

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ServicesDashboard/${{ matrix.asset_name }}

  release:
    name: Create Release
    needs: [build, docker]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Delete existing release and tag if they exist
        run: |
          TAG="v${{ needs.docker.outputs.version }}"
          echo "Checking for existing release/tag: $TAG"

          # Delete release if it exists (--cleanup-tag also removes the tag)
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG exists, deleting..."
            gh release delete "$TAG" --yes --cleanup-tag || true
            echo "Release and tag deleted"
          else
            echo "No existing release found"
          fi

          # Extra safety: ensure tag is deleted from remote
          git push origin ":refs/tags/$TAG" 2>/dev/null || echo "Tag already removed or doesn't exist"

          # Small delay to ensure GitHub processes the deletion
          sleep 2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Draft Release
        uses: softprops/action-gh-release@v1
        with:
          body: |
            ## 🚀 Release ${{ needs.docker.outputs.version }}

            ### 📦 Available Downloads

            #### Standalone Binaries
            Download the appropriate file for your platform from the assets below.

            #### Docker Images (Multi-platform)
            ```bash
            # Backend
            docker pull ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:${{ needs.docker.outputs.version }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-backend:latest

            # Frontend
            docker pull ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:${{ needs.docker.outputs.version }}
            docker pull ${{ secrets.DOCKER_USERNAME }}/servicesdashboard-frontend:latest

            # Deploy with Docker Compose
            docker compose -f compose.prod.yaml up -d
            ```

            Supported platforms: `linux/amd64`, `linux/arm64`

            ### 📝 Installation

            **Quick Install (Linux/macOS):**
            ```bash
            curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | sudo bash
            ```

            **Docker Compose:**
            See [DEPLOYMENT.md](https://github.com/${{ github.repository }}/blob/main/DEPLOYMENT.md) for detailed Docker and Portainer deployment instructions.

            > **⚠️ Note:** Raspberry Pi Zero / Pi 1 are NOT supported due to ARMv6 architecture limitations in .NET 9.0
          files: |
            **/*.tar.gz
            **/*.zip
          draft: true
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish Release
        run: |
          TAG="v${{ needs.docker.outputs.version }}"
          echo "Publishing release $TAG..."
          gh release edit "$TAG" --draft=false
          echo "✅ Release $TAG published successfully!"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
